import struct


# KSA
def ksa():
    S = bytearray(0x100)
    with open("key","rb") as finput:
        key = bytearray(finput.read())
        
    for i in range(0,0x100):
        S[i] = i
    j = 0

    for i in range(0,0x100):
        j = (j + S[i] + key[i]) % 0x100
        t = S[i]
        S[i] = S[j]
        S[j] = t
    
    return S


#custom PRGA
def c_prga(S, S_1, i, j):
    i = (i + 1) % 0x100
    j = (j + S[i]) % 0x100
    t = S[i]
    S[i] = S[j]
    S[j] = t
    k = S[(S[i] + S[j]) % 0x100]
    final_K = S_1[k]
    
    return (final_K, S, i, j)


# read in the encrypted payload file
with open("xwizard.dtd", "rb") as dtd_input:
    packed_file = bytearray(dtd_input.read())

# do KSA, get S
S = ksa()

# read in the keypool file, get S_1
with open("S_1", "rb") as keypool:
    S_1 = bytearray(keypool.read())

# declare numbers
# malware-specific header size is 0x5F bytes (incl. jumps and 0x47 bytes of values that xor with RC4 key)
malware_header_size = 0x5F
file_offset = malware_header_size   
sections_offset = 0
sections_pad_size = 0   
first_section_vaddr = 0
i = 0
j = 0
dos_header_size = 0x40
pe_header_size = 0xF8
section_header_size = 0x28

# declare results
unpacked_file = bytearray()
dos_header = bytearray()
pe_header = bytearray()
sections = bytearray()

# decrypt DOS header
ciphertext = packed_file[file_offset : file_offset + dos_header_size]
for c in ciphertext:
    (key, S, i, j) = c_prga(S, S_1, i, j)
    dos_header.append(key ^ c)
    
unpacked_file += dos_header 

# insert DOS Stub
pe_header_offset = int(struct.unpack("<I", dos_header[0x3C:0x3C+4])[0])
# add in padding after the DOS header, representing the DOS stub
dos_stub = bytearray(pe_header_offset - dos_header_size)
unpacked_file += dos_stub

file_offset += pe_header_offset

# decrypt PE header
ciphertext = packed_file[file_offset:file_offset+pe_header_size]
for c in ciphertext:
    (key, S, i, j) = c_prga(S, S_1, i, j)
    pe_header.append(key ^ c)
    
unpacked_file += pe_header

file_offset += pe_header_size


# decrypt section header and section body, in order
while packed_file[file_offset] != 0:
    # decrypt section header
    section_header = bytearray()
    ciphertext = packed_file[file_offset:file_offset+section_header_size]
    for c in ciphertext:
        (key, S, i, j) = c_prga(S, S_1, i, j)
        section_header.append(key ^ c)

    unpacked_file += section_header
    file_offset += section_header_size
        
    # read virtual/raw values from section header
    section_vsize = int(struct.unpack("<I", section_header[0x8:0xC])[0])
    section_vaddr = int(struct.unpack("<I", section_header[0xC:0x10])[0])
    section_rsize = int(struct.unpack("<I", section_header[0x10:0x14])[0])
    section_raddr = int(struct.unpack("<I", section_header[0x14:0x18])[0]) + malware_header_size
    
    # build padding after each section, to mimick file mapping in memory
    if sections_offset !=0:
        sections_pad_size = section_vaddr - sections_offset - first_section_vaddr
    else:
        first_section_vaddr = section_vaddr        
    sections += bytearray(sections_pad_size)
    
    # number of bytes to decrypt depending on smaller virtual/raw size
    if section_rsize <= section_vsize:
        section_size = section_rsize
    else:        
        section_size = section_vsize
        
    sections_offset += section_size + sections_pad_size
    
    # decrypt section body
    ciphertext = packed_file[section_raddr:section_raddr+section_size]
    for c in ciphertext:
        (key, S, i, j) = c_prga(S, S_1, i, j)
        sections.append(key ^ c)

# build padding between end of section table and start of section body
header_pad_size = first_section_vaddr - len(unpacked_file)
unpacked_file += bytearray(header_pad_size)
unpacked_file += sections

# done!
with open("unpacked_dtd","wb") as output_file:
    output_file.write(unpacked_file)
